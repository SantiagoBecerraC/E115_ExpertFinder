#!/usr/bin/env python3
"""
Standardize test files across the ExpertFinder project.

This script:
1. Ensures all test files have proper docstrings
2. Removes any unprofessional comments or references to AI assistance
3. Makes sure tests follow standard formatting and conventions
4. Adds proper docstrings to test functions if missing
"""

import os
import re
import sys
from pathlib import Path


def find_test_files(base_dir='backend'):
    """Find all test_*.py files in the project."""
    test_files = []
    for root, _, files in os.walk(base_dir):
        for file in files:
            if file.startswith('test_') and file.endswith('.py'):
                test_files.append(os.path.join(root, file))
    return test_files


def process_test_file(file_path):
    """Process a single test file to standardize it."""
    print(f"Processing: {file_path}")
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Check if file has changed after processing
    original_content = content
    
    # Remove commented-out code that's not being used
    content = remove_large_commented_sections(content)
    
    # Fix or add docstrings
    content = ensure_docstrings(content, file_path)
    
    # Remove any references to AI assistance
    content = remove_ai_references(content)
    
    # Update any unprofessional language
    content = fix_unprofessional_comments(content)
    
    # Write back changes if needed
    if content != original_content:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✅ Updated: {file_path}")
    else:
        print(f"✓ No changes needed: {file_path}")


def remove_large_commented_sections(content):
    """Remove large blocks of commented-out code."""
    # Find multiline comments that are more than 20 lines long
    pattern = r"'''.*?'''"
    matches = list(re.finditer(pattern, content, re.DOTALL))
    
    # Process matches from end to beginning to preserve positions
    for match in reversed(matches):
        comment_content = match.group(0)
        # Count number of lines
        if comment_content.count('\n') > 20:
            start, end = match.span()
            # Remove the comment
            content = content[:start] + content[end:]
    
    return content


def ensure_docstrings(content, file_path):
    """Ensure all test classes and methods have proper docstrings."""
    # Add file docstring if missing
    if not re.search(r'^""".*?"""', content, re.DOTALL) and not re.search(r"^'''.*?'''", content, re.DOTALL):
        file_name = os.path.basename(file_path)
        module_name = file_name.replace('test_', '').replace('.py', '')
        
        # Create a standard docstring
        docstring = f'"""\nUnit tests for the {module_name} module.\n\nThis test suite verifies functionality of {module_name}.\n"""\n\n'
        
        # Add after any imports or at the beginning if no imports
        imports_end = max(
            content.rfind('import '), 
            content.rfind('from '),
            content.find('\n\n')
        )
        
        if imports_end > 0:
            content = content[:imports_end+1] + '\n' + docstring + content[imports_end+1:]
        else:
            content = docstring + content
    
    # Ensure test methods have docstrings
    # Find all test methods
    test_methods = re.finditer(r'def (test_\w+)\(self', content)
    for match in test_methods:
        method_name = match.group(1)
        # Check if there's a docstring after the def line
        def_pos = match.start()
        next_lines = content[def_pos:def_pos+200].split('\n', 2)
        
        # If no docstring, add one
        if len(next_lines) >= 2 and not re.search(r'^\s+"""', next_lines[1]):
            # Get the indentation
            indent_match = re.match(r'(\s+)def', next_lines[0])
            if indent_match:
                indent = indent_match.group(1)
                # Create a descriptive docstring based on the method name
                description = ' '.join(w.capitalize() for w in method_name[5:].split('_'))
                docstring = f'{indent}    """{description}."""\n'
                
                # Insert after the def line
                pos = def_pos + len(next_lines[0]) + 1
                content = content[:pos] + docstring + content[pos:]
    
    return content


def remove_ai_references(content):
    """Remove any references to AI assistance."""
    ai_reference_patterns = [
        r'# Generated by .*?AI',
        r'# Created with the help of .*?AI',
        r'# GPT',
        r'# This is AI',
        r'# AI generated',
    ]
    
    for pattern in ai_reference_patterns:
        content = re.sub(pattern, '# ', content)
    
    return content


def fix_unprofessional_comments(content):
    """Fix any unprofessional comments."""
    unprofessional_patterns = [
        (r'# TODO', '# TODO:'),  # Standardize TODO format
        (r'# FIXME', '# FIXME:'),  # Standardize FIXME format
        (r'# hack', '# Note: Implementation detail'),  # Replace "hack" with more professional term
        (r'# ugly', '# Note: Could be improved'),  # Replace negative characterizations
    ]
    
    for pattern, replacement in unprofessional_patterns:
        content = re.sub(pattern, replacement, content)
    
    return content


def main():
    """Main function to process all test files."""
    if len(sys.argv) > 1:
        base_dir = sys.argv[1]
    else:
        base_dir = 'backend'
    
    test_files = find_test_files(base_dir)
    print(f"Found {len(test_files)} test files to process")
    
    for file_path in test_files:
        process_test_file(file_path)
    
    print("\nAll test files processed successfully!")


if __name__ == "__main__":
    main() 